# 0. 概览

背包问题是动态规划非常重要的一类问题，它有很多变种，但题目万变不离其宗。
![[Paste.png]]
>[! tip]
>万能遍历顺序：物品种类——>容量——>物品数量
>
## 1. 01背包问题⭐

### 问题描述

每个元素最多取**1**次。具体来讲：一共有 N 件物品，第 i（i 从 1 开始）件物品的重量为 w[i]，价值为 v[i]。在总重量不超过背包承载上限 W 的情况下，能够装入背包的最大价值是多少？

### 解题模板

#### 1.二维数组版本

 ```java

int solve01Bag(int[] weight, int[] value, int bagSize){
  // 物品数量
  int goodsNum = weight.length;

  // 创建dp数组
  int[][] dp = new int[goodsNum][bagSize + 1];

  // 初始化dp数组,创建数组后，其中默认的值就是0
  for (int j = weight[0]; j <= bagSize; j++) {
    dp[0][j] = value[0];
  }

  // 填充dp数组
  for (int i = 1; i < goodsNum; i++) {
    for (int j = 1; j <= bagSize; j++) {
      if (j < weight[i]) {
        /**
        * 当前背包的容量都没有当前物品i大的时候，是不放物品i的
        * 那么前i-1个物品能放下的最大价值就是当前情况的最大价值
          */
        dp[i][j] = dp[i-1][j];
      } else {
          /**
          * 当前背包的容量可以放下物品i
          * 那么此时分两种情况：
          * 1、不放物品i
          * 2、放物品i
          * 比较这两种情况下，哪种背包中物品的最大价值最大
            */
          dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i]);
      }
    }
  }
  return dp[goodsNum - 1][bagSize];
}

 ```

#### 2.一维(滚动数组)数组版本

```java
int solve01Bag(int[] weight, int[] value, int bagSize){
  int goodsNum = weight.length;
  //定义dp数组：dp[j]表示背包容量为j时，能获得的最大价值
  int[] dp = new int[bagSize + 1];

  //遍历顺序：先遍历物品，再遍历背包容量
  for (int i = 0; i < wLen; i++){
    // 遍历容量（倒序），放置重复放置物品
    for (int j = bagSize; j >= weight[i]; j--){
      dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
    }
  }
  return dp[bagWeight];
}
```

>[! tip] 滚动数组版本遍历背包容量必须倒叙遍历，不然会放置重复物品（变成了完全背包问题）
>
### 相关例题

1. [卡码网46](https://kamacoder.com/problem.php?id=1046)
2. [力扣416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

## 2. 完全背包问题

### 问题描述

有 N 件物品和一个最多能背重量为 W 的背包。第 i 件物品的重量是 weight[i]，得到的价值是 value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。

### 代码模板

```java
int solveCompleteBag(int[] weight, int[] value, int goodsNum, int bagSize){
  int[] dp = new int[bagSize + 1];

  // 遍历物品
  for(int i = 0; i < goodsNum; i++){
    // 遍历背包大小（正序）
    for(int j = weight[i]; j <= bagSize; j++){
      dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
    }
  }
  return dp[bagSize];
}
```

>[!tip] 纯完全背包问题两层循环可以交换。
>但如果题目稍稍有点变化，就会体现在遍历顺序上。比如：如果问装满背包有几种方式的话？ 那么两个 for 循环的先后顺序就有很大区别了

### 相关例题

1. [卡码网 52 题]( https://kamacoder.com/problem.php?id=1052 )

## 3. 多重背包问题

### 问题描述

有N种物品和一个容量为V 的背包。第i种物品**最多有Mi件可用**，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。

### 代码模板

```java
int solveMultiPack(int[] weight, int[] value, int[] nums, int goodsNum, int bagSize){
 int[] dp = new int[bagSize + 1];
  // 遍历物品
  for(int i = 0; i < weight.length; i++) { 
    // 遍历背包容量
    for(int j = bagSize; j >= weight[i]; j--) { 
      // 遍历个数
      for (int k = 1; k <= nums[i] && j >= k * weight[i]; k++) { 
        dp[j] = Math.max(dp[j], dp[j - k*weight[i]] + k*value[i]);
      }
    }
  }
  return dp[bagSize];
}
```

>[! tip] 核心思路就是：转换为 01 背包问题。
>
### 相关例题

1. [卡码网56题](https://kamacoder.com/problem.php?id=1066)

## 4. 相关资料

1. 背包九讲----经典中的经典
2. [代码随想录—动态规划部分](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html)
